// Copyright (c) 2007, Clarius Consulting, Manas Technology Solutions, InSTEDD.
// All rights reserved. Licensed under the BSD 3-Clause License; see License.txt.

using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Text;

namespace Moq
{
	internal sealed class CompositeSetupBuilder : ICompositeSetup
	{
		private readonly LambdaExpression expression;
		private readonly List<ISetup> parts;

		public CompositeSetupBuilder(LambdaExpression expression)
		{
			Debug.Assert(expression != null);

			this.expression = expression;
			this.parts = new List<ISetup>();
		}

		public LambdaExpression Expression => this.expression;

		public IReadOnlyList<ISetup> Parts => this.parts;

		public bool IsConditional => this.parts.First().IsConditional;

		bool ISetup.IsDisabled => this.parts.Any(p => p.IsDisabled);

		public bool IsMatched => this.parts.All(p => p.IsMatched);

		public bool IsVerifiable => this.parts.Last().IsVerifiable;

		public void AddPart(ISetup setup)
		{
			this.parts.Add(setup);
		}

		bool ISetup.IsPartOfCompositeSetup(out ICompositeSetup originalSetup)
		{
			originalSetup = default;
			return false;
		}

		bool ISetup.ReturnsInnerMock(out Mock innerMock)
		{
			innerMock = default;
			return false;
		}

		public void Verify()
		{
			// TODO:
			// The exception generated by this method could be more precise by giving a hint
			// which part caused the setup as a whole to fail.

			// A composite setup only passes verification if the rightmost part does, too.
			try
			{
				this.parts.Last().Verify();
			}
			catch (MockException ex) when (ex.IsVerificationError)
			{
				throw MockException.UnmatchedSetup(this);
			}

			// But that's not enough: The rightmost part must have been called through all those on the left.
			foreach (var part in this.parts)
			{
				if (!part.IsMatched)
				{
					throw MockException.UnmatchedSetup(this);
				}
			}
		}

		public override string ToString()
		{
			var expression = this.Expression;
			var mockedType = expression.Parameters[0].Type;

			var builder = new StringBuilder();
			builder.AppendNameOf(mockedType)
			       .Append(' ')
			       .Append(expression.PartialMatcherAwareEval().ToStringFixed());

			return builder.ToString();
		}
	}
}
